<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Generator v2.8</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root {
            --color-background: #f8f9fa;
            --color-container-bg: #f8f9fa;
            --color-text-primary: #212529;
            --color-text-secondary: #6c757d;
            --color-heading: #343a40;
            --color-grid-lines: #adb5bd;
            --color-grid-box-lines: #212529; 
            --color-grid-cell-bg: #fff;
            --color-grid-given-text: #000;
            --color-grid-user-text: #007bff;
            --color-grid-selected-bg: #d0e8ff;
            --color-grid-related-bg: #e9ecef;
            --color-grid-highlighted-bg: #cce5ff;
            --color-button-disabled-bg: #6c757d;
            --color-spinner-track: #f3f3f3;
            --color-modal-bg: rgba(0, 0, 0, 0.6);
            --color-modal-content-bg: white;
            --color-box-shadow: rgba(0,0,0,0.1);
            --color-box-shadow-hover: rgba(0,0,0,0.15);
            --color-primary: #007bff;
            --color-success: #28a745;
            --color-danger: #dc3545;
            --color-warning: #ffc107;
            --color-info: #6f42c1;
            --color-pink: #d63384;
            --color-correct-bg: rgba(40, 167, 69, 0.3);
            --color-incorrect-bg: rgba(220, 53, 69, 0.4);
            --color-conflict-text: #dc3545;
        }

        body.dark-mode {
            --color-background: #121212;
            --color-container-bg: #1e1e1e;
            --color-text-primary: #e0e0e0;
            --color-text-secondary: #888;
            --color-heading: #f1f1f1;
            --color-grid-lines: #444;
            --color-grid-box-lines: #e0e0e0;
            --color-grid-cell-bg: #2a2a2a;
            --color-grid-given-text: #fff;
            --color-grid-user-text: #58a6ff;
            --color-grid-selected-bg: #3a5a78;
            --color-grid-related-bg: #343a40;
            --color-grid-highlighted-bg: #004a9e;
            --color-button-disabled-bg: #555;
            --color-spinner-track: #444;
            --color-modal-bg: rgba(0, 0, 0, 0.8);
            --color-modal-content-bg: #2c2c2c;
            --color-box-shadow: rgba(0,0,0,0.3);
            --color-box-shadow-hover: rgba(0,0,0,0.4);
            --color-correct-bg: rgba(40, 167, 69, 0.4);
            --color-incorrect-bg: rgba(220, 53, 69, 0.5);
            --color-conflict-text: #ff7b7b;
        }

        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; font-size: 16px; color: var(--color-text-primary); background-color: var(--color-background); padding: 20px; margin: 0; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; transition: background-color 0.3s, color 0.3s; }
        .container { width: 100%; max-width: 900px; margin: 0 auto; text-align: center; }
        
        .main-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .main-header h1 { flex-grow: 1; margin: 0; padding: 0 10px; text-align: center; }
        .header-buttons { display: flex; gap: 10px; }
        .header-spacer { min-width: 100px; flex-shrink: 0; }
        
        #puzzle-container { display: flex; margin-top: 20px; justify-content: center; }
        #grid-wrapper { position: relative; }
        #grid-wrapper:fullscreen { background-color: var(--color-background); padding: 20px; display: flex; flex-direction: column; justify-content: center; align-items: center; gap: 20px; }
        body:has(#grid-wrapper:fullscreen) .main-header,
        body:has(#grid-wrapper:fullscreen) .global-options-container,
        body:has(#grid-wrapper:fullscreen) .controls-grid,
        body:has(#grid-wrapper:fullscreen) .panel,
        body:has(#grid-wrapper:fullscreen) #status-container,
        body:has(#grid-wrapper:fullscreen) #version-info {
            display: none;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(9, auto);
            background-color: var(--color-grid-box-lines);
            border-right: 3px solid var(--color-grid-box-lines);
            border-bottom: 3px solid var(--color-grid-box-lines);
            border-radius: 5px;
            overflow: hidden; 
        }

        .grid-cell {
            background-color: var(--color-grid-cell-bg);
            color: var(--color-grid-user-text);
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s, color 0.2s;
            border-top: 1px solid var(--color-grid-lines);
            border-left: 1px solid var(--color-grid-lines);
            box-sizing: border-box; /* Fix for squashed row */
        }

        .grid-cell[data-row="0"], .grid-cell[data-row="3"], .grid-cell[data-row="6"] {
            border-top-width: 3px;
            border-top-color: var(--color-grid-box-lines);
        }
        .grid-cell[data-col="0"], .grid-cell[data-col="3"], .grid-cell[data-col="6"] {
            border-left-width: 3px;
            border-left-color: var(--color-grid-box-lines);
        }

        .grid-cell.given-cell { color: var(--color-grid-given-text); font-weight: normal;}
        .grid-cell.selected { background-color: var(--color-grid-selected-bg); }
        .grid-cell.related-cell { background-color: var(--color-grid-related-bg); }
        .grid-cell.highlighted { background-color: var(--color-grid-highlighted-bg); }
        
        .grid-cell.hint-cell { color: var(--color-info); }
        .grid-cell.conflict-cell { color: var(--color-conflict-text); }
        .flash-conflict { animation: flash-red-bg 0.5s ease; }
        @keyframes flash-red-bg { 50% { background-color: var(--color-incorrect-bg); } }

        .loader { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; flex-direction: column; gap: 15px; z-index: 10; font-size: 1.1em; color: white; border-radius: 4px; }
        .loader.hidden { opacity: 0; pointer-events: none; }
        #cancel-book-btn { display: none; }
        .spinner { border: 4px solid var(--color-spinner-track); border-top: 4px solid var(--color-primary); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        
        .global-options-container { display: flex; justify-content: center; align-items: center; gap: 10px 25px; margin-top: 25px; font-size: 1em; color: var(--color-text-primary); }
        .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; max-width: 415px; margin: 25px auto 0 auto; }
        .option-group { display: flex; align-items: center; gap: 10px; }
        
        button { padding: 12px 20px; font-size: 1em; font-weight: bold; cursor: pointer; color: white; border: none; border-radius: 5px; transition: all 0.2s; box-shadow: 0 2px 4px var(--color-box-shadow); width: 100%; box-sizing: border-box; }
        button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 8px var(--color-box-shadow-hover); }
        button:disabled { background-color: var(--color-button-disabled-bg); cursor: not-allowed; opacity: 0.7; }
        #generate-btn { background-color: var(--color-primary); }
        #reveal-btn { background-color: var(--color-success); }
        #download-pdf-btn { background-color: var(--color-pink); }
        #create-puzzle-btn { background-color: var(--color-warning); }
        #make-book-btn { background-color: var(--color-danger); }
        #hint-btn { background-color: var(--color-info); }
        
        .panel { max-width: 415px; margin: 25px auto 0; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px var(--color-box-shadow); display: none; }
        .panel h3 { margin-top: 0; }
        .panel p { font-size: 0.9em; color: var(--color-text-secondary); margin-bottom: 15px; text-align: left; }
        
        #start-created-puzzle-btn, #create-book-btn { background-color: var(--color-success); }
        #cancel-create-puzzle-btn, #cancel-book-options-btn { background-color: var(--color-text-secondary); }

        .create-options-grid { display: grid; grid-template-columns: auto 1fr; gap: 10px 15px; align-items: center; margin-bottom: 15px; }
        .create-options-grid label { text-align: right; }
        .create-options-grid input[type="number"] { width: 70px; }

        .book-options-grid { display: grid; grid-template-columns: auto 1fr; gap: 10px 15px; align-items: center; }
        .book-options-grid label { text-align: right; }
        #book-checkbox-options { display: flex; gap: 20px; align-items: center; justify-content: flex-start; }
        
        #number-panel { display: flex; justify-content: center; gap: 5px; margin: 20px auto 0; max-width: fit-content; transition: width 0.3s ease; }
        .number-cell { width: 40px; height: 40px; display: flex; justify-content: center; align-items: center; font-size: 1.5em; font-weight: bold; border: 2px solid var(--color-grid-box-lines); border-radius: 4px; cursor: pointer; transition: all 0.2s; background-color: var(--color-grid-cell-bg); flex: 1; }
        .number-cell:hover { background-color: var(--color-grid-related-bg); }
        .number-cell.used-up {
            background-color: var(--color-grid-cell-bg);
            color: var(--color-text-secondary);
            text-decoration: line-through;
            font-weight: normal;
            cursor: default;
        }

        #status-container { text-align: center; margin-top: 15px; font-style: italic; min-height: 20px; color: var(--color-text-secondary); }
        #version-info { text-align: center; margin-top: 20px; font-size: 0.8em; color: var(--color-grid-lines); }
        
        #completion-modal { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--color-modal-bg); display: flex; justify-content: center; align-items: center; z-index: 20; opacity: 0; pointer-events: none; transition: opacity 0.3s ease-in-out; border-radius: 5px; }
        #completion-modal.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background-color: var(--color-modal-content-bg); padding: 40px; border-radius: 10px; text-align: center; box-shadow: 0 5px 15px var(--color-box-shadow); transform: scale(0.9); transition: transform 0.3s ease-in-out; }
        #completion-modal.visible .modal-content { transform: scale(1); }
        .modal-content h2 { font-size: 2.5em; margin-top: 0; margin-bottom: 20px; color: var(--color-success); }
        .modal-content button { min-width: 150px; background-color: var(--color-primary); }
        #completion-details { margin-bottom: 25px; font-size: 1.1em; color: var(--color-text-primary); }
        #completion-details p { margin: 5px 0; }
        #new-best-time { color: var(--color-warning); font-weight: bold; }

        #fullscreen-btn, #theme-toggle-btn { background: none; border: 2px solid var(--color-text-secondary); color: var(--color-text-secondary); width: 44px; height: 44px; padding: 0; border-radius: 50%; display: flex; justify-content: center; align-items: center; overflow: hidden; box-shadow: none; flex-shrink: 0; }
        #fullscreen-btn:hover, #theme-toggle-btn:hover { border-color: var(--color-text-primary); color: var(--color-text-primary); transform: none; box-shadow: none; }
        #fullscreen-btn svg, #theme-toggle-btn svg { width: 24px; height: 24px; fill: currentColor; }
        .icon-sun, .icon-moon { display: none; }
        body.dark-mode .icon-sun { display: block; }
        body:not(.dark-mode) .icon-moon { display: block; }

        @media (max-width: 480px) {
            .main-header h1 { font-size: 1.8em; }
            .controls-grid { grid-template-columns: 1fr; }
            .grid-cell { font-size: 1.2em; }
            .number-cell { width: 32px; height: 32px; font-size: 1.2em; }
            .book-options-grid, .create-options-grid { grid-template-columns: 1fr; }
            .book-options-grid label, .create-options-grid label { text-align: left; }
        }
    </style>
</head>
<body>
    <div class="container" id="container">
        <header class="main-header">
            <div class="header-spacer"></div>
            <h1>Sudoku Generator</h1>
            <div class="header-buttons">
                 <button id="fullscreen-btn" title="Toggle Fullscreen (F)">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
                </button>
                <button id="theme-toggle-btn" title="Toggle Theme">
                    <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.64 5.64c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41zm12.73 12.73c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41zM5.64 18.36c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0zM18.36 5.64c-.39.39-.39-1.02 0 1.41.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.38-1.03-.38-1.41 0z"/></svg>
                    <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" viewBox="0 0 24 24"><path d="M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.11-1.36c-0.98,1.37-2.58,2.26-4.39,2.26 c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.39C12.92,3.04,12.46,3,12,3z"/></svg>
                </button>
            </div>
        </header>

        <div id="puzzle-container">
            <div id="grid-wrapper">
                <div id="grid"></div>
                <div id="loader" class="loader hidden">
                    <div class="spinner"></div>
                    <span id="loader-text">Generating Puzzle...</span>
                    <button id="cancel-book-btn" style="display:none;">Cancel</button>
                </div>
                <div id="completion-modal">
                    <div class="modal-content">
                        <h2>You Solved It!</h2>
                        <div id="completion-details">
                            <p id="your-time"></p>
                            <p id="best-time"></p>
                            <p id="new-best-time"></p>
                        </div>
                        <button>Play Again?</button>
                    </div>
                </div>
                <div id="number-panel"></div>
            </div>
        </div>
        
        <div class="global-options-container">
            <div class="option-group">
                <label for="difficulty-select"><b>Difficulty:</b></label>
                <select id="difficulty-select">
                    <option value="easy">Easy</option>
                    <option value="medium" selected>Medium</option>
                    <option value="hard">Hard</option>
                    <option value="expert">Expert</option>
                </select>
            </div>
        </div>

        <div class="controls-grid" id="main-controls">
            <button id="generate-btn">New Puzzle</button>
            <button id="create-puzzle-btn">Create Puzzle</button>
            <button id="hint-btn">Hint</button>
            <button id="reveal-btn">Reveal Solution</button>
            <button id="download-pdf-btn">Download as PDF</button>
            <button id="make-book-btn">Make Book</button>
        </div>

        <div id="create-puzzle-panel" class="panel">
            <h3>Create a Custom Puzzle</h3>
            <p>Define a structure for your puzzle by choosing how many rows, columns, or 3x3 boxes should be complete. The generator will create a valid puzzle based on your choices.</p>
            <div class="create-options-grid">
                <label for="completed-rows-input">Completed Rows:</label>
                <input type="number" id="completed-rows-input" value="0" min="0" max="9">
                <label for="completed-cols-input">Completed Columns:</label>
                <input type="number" id="completed-cols-input" value="0" min="0" max="9">
                <label for="completed-boxes-input">Completed Boxes:</label>
                <input type="number" id="completed-boxes-input" value="0" min="0" max="9">
            </div>

            <div class="controls-grid">
                <button id="start-created-puzzle-btn">Create & Start</button>
                <button id="cancel-create-puzzle-btn">Cancel</button>
            </div>
        </div>
        
        <div id="generate-book-panel" class="panel">
            <h3>Make a Sudoku Book</h3>
            <div class="book-options-grid">
                <label for="book-title-input">Book Title:</label>
                <input type="text" id="book-title-input" placeholder="e.g., My Sudoku Book">
                
                <label for="book-subtitle-input">Subtitle:</label>
                <input type="text" id="book-subtitle-input" placeholder="e.g., By Alex Doe">

                <label for="puzzle-count-input">Puzzles:</label>
                <input type="number" id="puzzle-count-input" value="20" min="1" max="100" style="width: 70px;">
                
                <label for="puzzles-per-page-select">Puzzles/Page:</label>
                <select id="puzzles-per-page-select">
                    <option value="1">1</option>
                    <option value="2" selected>2</option>
                    <option value="4">4</option>
                </select>

                <label>Options:</label>
                <div id="book-checkbox-options">
                    <label><input type="checkbox" id="answer-key-checkbox" checked> Answer Key</label>
                    <label><input type="checkbox" id="page-numbers-checkbox" checked> Page Numbers</label>
                </div>
            </div>
            <div class="controls-grid">
                <button id="create-book-btn">Create Book</button>
                <button id="cancel-book-options-btn">Cancel</button>
            </div>
        </div>

        <div id="status-container"><p id="source-status"></p></div>
        <div id="version-info">v2.8</div>
    </div>
    
    <script>
        // --- GLOBAL VARIABLES & CONSTANTS ---
        const ui = {
            grid: document.getElementById('grid'),
            numberPanel: document.getElementById('number-panel'),
            gridWrapper: document.getElementById('grid-wrapper'),
            puzzleContainer: document.getElementById('puzzle-container'),
            loader: document.getElementById('loader'),
            loaderText: document.getElementById('loader-text'),
            cancelBookBtn: document.getElementById('cancel-book-btn'),
            difficultySelect: document.getElementById('difficulty-select'),
            status: document.getElementById('source-status'),
            generateBtn: document.getElementById('generate-btn'),
            revealBtn: document.getElementById('reveal-btn'),
            hintBtn: document.getElementById('hint-btn'),
            downloadPdfBtn: document.getElementById('download-pdf-btn'),
            makeBookBtn: document.getElementById('make-book-btn'),
            completionModal: document.getElementById('completion-modal'),
            fullscreenBtn: document.getElementById('fullscreen-btn'),
            themeToggleBtn: document.getElementById('theme-toggle-btn'),
            mainControls: document.getElementById('main-controls'),
            createPuzzlePanel: document.getElementById('create-puzzle-panel'),
            createPuzzleBtn: document.getElementById('create-puzzle-btn'),
            startCreatedPuzzleBtn: document.getElementById('start-created-puzzle-btn'),
            cancelCreatePuzzleBtn: document.getElementById('cancel-create-puzzle-btn'),
            completedRowsInput: document.getElementById('completed-rows-input'),
            completedColsInput: document.getElementById('completed-cols-input'),
            completedBoxesInput: document.getElementById('completed-boxes-input'),
            generateBookPanel: document.getElementById('generate-book-panel'),
            createBookBtn: document.getElementById('create-book-btn'),
            cancelBookOptionsBtn: document.getElementById('cancel-book-options-btn')
        };

        let puzzleBoard = [], solutionBoard = [], userBoard = [];
        let selectedCell = { row: -1, col: -1 };
        let startTime, puzzleConfigKey;
        
        let hintedCells = new Set();
        let conflictCells = new Set();
        let isGeneratingBook = false;

        // --- SUDOKU CORE LOGIC ---

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function findEmpty(board) {
            for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) if (board[r][c] === 0) return [r, c];
            return null;
        }

        function isValid(board, row, col, num) {
            for (let i = 0; i < 9; i++) {
                if ((board[row][i] === num && i !== col) || (board[i][col] === num && i !== row)) return false;
            }
            const boxRow = Math.floor(row / 3) * 3, boxCol = Math.floor(col / 3) * 3;
            for (let r = 0; r < 3; r++) for (let c = 0; c < 3; c++) {
                if ((boxRow + r !== row || boxCol + c !== col) && board[boxRow + r][boxCol + c] === num) return false;
            }
            return true;
        }

        function solve(board) {
            const emptyPos = findEmpty(board);
            if (!emptyPos) return true;
            const [r, c] = emptyPos;
            const nums = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);
            for (const num of nums) {
                if (isValid(board, r, c, num)) {
                    board[r][c] = num;
                    if (solve(board)) return true;
                    board[r][c] = 0;
                }
            }
            return false;
        }
        
        let solutionCounter;
        function countSolutions(board) {
            const emptyPos = findEmpty(board);
            if (!emptyPos) {
                solutionCounter++;
                return;
            }
            const [r, c] = emptyPos;
            for (let num = 1; num <= 9 && solutionCounter < 2; num++) {
                if (isValid(board, r, c, num)) {
                    board[r][c] = num;
                    countSolutions(board);
                    board[r][c] = 0;
                }
            }
        }
        
        function getCluesForDifficulty(difficulty) {
             switch(difficulty) {
                case 'easy': return 35;
                case 'medium': return 30;
                case 'hard': return 25;
                case 'expert': return 22;
                default: return 30;
            }
        }

        function generateSudoku(options = {}) {
            const board = Array(9).fill(0).map(() => Array(9).fill(0));
            solve(board);
            const solution = JSON.parse(JSON.stringify(board));
            let puzzle = JSON.parse(JSON.stringify(solution));

            const mandatoryClues = new Set();
            if (options.completedRowCount > 0) {
                const rows = shuffle([...Array(9).keys()]).slice(0, options.completedRowCount);
                rows.forEach(r => { for(let c=0; c<9; c++) mandatoryClues.add(`${r},${c}`); });
            }
            if (options.completedColCount > 0) {
                const cols = shuffle([...Array(9).keys()]).slice(0, options.completedColCount);
                cols.forEach(c => { for(let r=0; r<9; r++) mandatoryClues.add(`${r},${c}`); });
            }
            if (options.completedBoxCount > 0) {
                const boxes = shuffle([...Array(9).keys()]).slice(0, options.completedBoxCount);
                boxes.forEach(b => {
                    const startRow = Math.floor(b / 3) * 3, startCol = (b % 3) * 3;
                    for(let r=0; r<3; r++) for(let c=0; c<3; c++) mandatoryClues.add(`${startRow+r},${startCol+c}`);
                });
            }

            let removalCandidates = [];
            for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
                if (!mandatoryClues.has(`${r},${c}`)) {
                    removalCandidates.push([r, c]);
                }
            }
            shuffle(removalCandidates);

            if (mandatoryClues.size === 0) {
                const cluesToKeep = getCluesForDifficulty(options.difficulty);
                const cellsToRemoveCount = 81 - cluesToKeep;
                removalCandidates = removalCandidates.slice(0, cellsToRemoveCount);
            }

            for (const [r, c] of removalCandidates) {
                const backup = puzzle[r][c];
                puzzle[r][c] = 0;
                
                const tempBoard = JSON.parse(JSON.stringify(puzzle));
                solutionCounter = 0;
                countSolutions(tempBoard);
                
                if (solutionCounter !== 1) {
                    puzzle[r][c] = backup;
                }
            }

            return { puzzle, solution };
        }


        // --- UI & DISPLAY LOGIC ---

        function updateConflicts() {
            const oldConflicts = new Set(conflictCells);
            conflictCells.clear();
            const fullBoard = puzzleBoard.map((row, r) => row.map((cell, c) => cell === 0 ? userBoard[r][c] : cell));

            for(let r = 0; r < 9; r++) {
                for(let c = 0; c < 9; c++) {
                    const num = fullBoard[r][c];
                    if (num === 0 || puzzleBoard[r][c] !== 0 || hintedCells.has(`${r},${c}`)) continue;
                    
                    for(let i = 0; i < 9; i++) {
                        if (i !== c && fullBoard[r][i] === num) conflictCells.add(`${r},${c}`);
                        if (i !== r && fullBoard[i][c] === num) conflictCells.add(`${r},${c}`);
                    }
                    const boxRow = Math.floor(r / 3) * 3, boxCol = Math.floor(c / 3) * 3;
                    for(let i = 0; i < 3; i++) {
                        for(let j = 0; j < 3; j++) {
                            const curR = boxRow + i, curC = boxCol + j;
                            if ((curR !== r || curC !== c) && fullBoard[curR][curC] === num) conflictCells.add(`${r},${c}`);
                        }
                    }
                }
            }
            return new Set([...conflictCells].filter(x => !oldConflicts.has(x)));
        }


        function isBoardFull() {
            for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) if (puzzleBoard[r][c] === 0 && userBoard[r][c] === 0) return false;
            return true;
        }

        function setUiLoading(isLoading, message = 'Generating Puzzle...') {
            document.querySelectorAll('button, select, input').forEach(el => el.disabled = isLoading);
            ui.loaderText.textContent = message;
            ui.loader.classList.toggle('hidden', !isLoading);
            ui.cancelBookBtn.style.display = 'none';
        }
        
        function updateNumberPanel() {
            const counts = {};
            for(let i = 1; i <= 9; i++) counts[i] = 0;

            const fullBoard = puzzleBoard.map((row, r) => row.map((cell, c) => cell === 0 ? userBoard[r][c] : cell));
            fullBoard.flat().forEach(num => { if(num !== 0) counts[num]++; });
            
            for(let i = 1; i <= 9; i++) {
                const cell = ui.numberPanel.querySelector(`[data-number="${i}"]`);
                if(cell) cell.classList.toggle('used-up', counts[i] === 9);
            }
        }

        function updateGridDisplay() {
            const newConflictCoords = updateConflicts();
            ui.grid.innerHTML = '';
            
            const isFullscreen = !!document.fullscreenElement;
            const containerWidth = isFullscreen ? window.innerWidth * 0.8 : ui.puzzleContainer.clientWidth;
            const containerHeight = isFullscreen ? window.innerHeight * 0.8 : 600;
            
            const containerSize = Math.min(containerWidth, containerHeight, 600);
            const cellSize = Math.floor(containerSize / 9);
            const gridTotalSize = cellSize * 9;

            ui.grid.style.width = `${gridTotalSize}px`;
            ui.grid.style.height = `${gridTotalSize}px`;
            ui.grid.style.gridTemplateColumns = `repeat(9, ${cellSize}px)`;
            ui.grid.style.gridTemplateRows = `repeat(9, ${cellSize}px)`;
            
            const selectedValue = (selectedCell.row !== -1) ? (userBoard[selectedCell.row][selectedCell.col] || puzzleBoard[selectedCell.row][selectedCell.col]) : 0;

            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.style.fontSize = `${cellSize * 0.5}px`;
                    
                    const coordKey = `${r},${c}`;
                    const isGiven = puzzleBoard.length > 0 && puzzleBoard[r][c] !== 0;
                    const isHinted = hintedCells.has(coordKey);
                    const currentValue = isGiven ? puzzleBoard[r][c] : (userBoard.length > 0 ? userBoard[r][c] : 0);
                    
                    cell.textContent = currentValue === 0 ? '' : currentValue;
                    if (isGiven) cell.classList.add('given-cell');
                    if (isHinted) cell.classList.add('hint-cell');
                    if (conflictCells.has(coordKey)) cell.classList.add('conflict-cell');
                    if (newConflictCoords.has(coordKey)) {
                        cell.classList.add('flash-conflict');
                        cell.addEventListener('animationend', () => cell.classList.remove('flash-conflict'), { once: true });
                    }
                    
                    if (selectedCell.row !== -1) {
                         if (r === selectedCell.row && c === selectedCell.col) cell.classList.add('selected');
                         else if (r === selectedCell.row || c === selectedCell.col || (Math.floor(r/3) === Math.floor(selectedCell.row/3) && Math.floor(c/3) === Math.floor(selectedCell.col/3))) {
                            cell.classList.add('related-cell');
                        }
                        if (selectedValue !== 0 && currentValue === selectedValue) cell.classList.add('highlighted');
                    }
                    ui.grid.appendChild(cell);
                }
            }

            // Style Number Panel to match grid width
            ui.numberPanel.style.width = `${gridTotalSize}px`;
            const numberCells = ui.numberPanel.querySelectorAll('.number-cell');
            const numberCellHeight = isFullscreen ? (gridTotalSize / 9) : 40;
            numberCells.forEach(cell => {
                cell.style.height = `${numberCellHeight}px`;
                cell.style.fontSize = `${numberCellHeight * 0.6}px`;
            });

            updateNumberPanel();
        }

        async function startNewGame(puzzlePromise) {
            setUiLoading(true);
            ui.status.textContent = '';
            hintedCells.clear();
            
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                const { puzzle, solution, source } = await puzzlePromise;
                puzzleBoard = puzzle;
                solutionBoard = solution;
                userBoard = Array(9).fill(0).map(() => Array(9).fill(0));
                handleCellClick(-1, -1); 
                
                startTime = Date.now();
                const clueCount = puzzle.flat().filter(c => c !== 0).length;
                puzzleConfigKey = `sudoku-custom-${puzzle.join('')}`;
                ui.status.textContent = source ? `${source} (${clueCount} Clues)` : `Custom Puzzle (${clueCount} Clues)`;

            } catch(error) {
                ui.status.textContent = `Error: ${error.message}`;
                alert(`Error: ${error.message}`);
                console.error(error);
            } finally {
                setUiLoading(false);
                updateGridDisplay();
            }
        }

        function checkFinalSolution() {
            for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
                if (solutionBoard[r][c] !== (userBoard[r][c] || puzzleBoard[r][c])) return false;
            }
            return true;
        }

        function revealSolution() {
            userBoard = JSON.parse(JSON.stringify(solutionBoard));
            handleCellClick(-1,-1);
            ui.hintBtn.disabled = true;
            ui.revealBtn.disabled = true;
        }

        function giveHint() {
            const emptyCells = [];
            for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
                if (puzzleBoard[r][c] === 0 && userBoard[r][c] === 0) emptyCells.push({ r, c });
            }
            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const { r, c } = randomCell;
                userBoard[r][c] = solutionBoard[r][c];
                hintedCells.add(`${r},${c}`);
                handleCellClick(r,c);
                if (isBoardFull() && checkFinalSolution()) handlePuzzleCompletion();
            } else {
                ui.status.textContent = "No empty cells to provide a hint for!";
            }
        }
        
        function handlePuzzleCompletion() {
            const elapsedTime = Date.now() - startTime;
            const bestTime = localStorage.getItem(puzzleConfigKey);
            let isNewBest = false;
            if (!bestTime || elapsedTime < parseInt(bestTime, 10)) {
                localStorage.setItem(puzzleConfigKey, elapsedTime);
                isNewBest = true;
            }
            const formatTime = (ms) => {
                const s = Math.floor(ms / 1000);
                return `${String(Math.floor(s / 60)).padStart(2, '0')}:${String(s % 60).padStart(2, '0')}`;
            };
            document.getElementById('your-time').textContent = `Your time: ${formatTime(elapsedTime)}`;
            document.getElementById('best-time').textContent = `Best time: ${formatTime(localStorage.getItem(puzzleConfigKey))}`;
            document.getElementById('new-best-time').textContent = isNewBest ? 'New Best Time!' : '';
            ui.completionModal.classList.add('visible');
        }

        function handleCellClick(row, col) {
            selectedCell.row = row;
            selectedCell.col = col;
            updateGridDisplay();
        }

        function showPanel(panel) {
            ui.mainControls.style.display = 'none';
            ui.createPuzzlePanel.style.display = 'none';
            ui.generateBookPanel.style.display = 'none';
            
            if (panel) {
                panel.style.display = 'block';
            }
        }
        
        function hidePanel() {
             ui.mainControls.style.display = 'grid';
             ui.createPuzzlePanel.style.display = 'none';
             ui.generateBookPanel.style.display = 'none';
        }

        // --- PDF Generation ---
        function drawSingleSudokuGrid(doc, { puzzle, solution }, startX, startY, gridTotalSize, showSolution = false) {
            const cellSize = gridTotalSize / 9;
            const fontSize = (cellSize * 0.5) / 0.352778; 
            doc.setFont('helvetica', 'normal').setFontSize(fontSize).setTextColor(0);
            for (let r = 0; r < 9; r++) for (let c = 0; c < 9; c++) {
                const num = showSolution ? solution[r][c] : puzzle[r][c];
                if (num !== 0) doc.text(String(num), startX + c * cellSize + cellSize / 2, startY + r * cellSize + cellSize / 2, { align: 'center', baseline: 'middle' });
            }
            doc.setDrawColor(0);
            for (let i = 0; i <= 9; i++) {
                const isThick = i % 3 === 0;
                doc.setLineWidth(isThick ? 0.6 : 0.2);
                doc.line(startX, startY + i * cellSize, startX + gridTotalSize, startY + i * cellSize);
                doc.line(startX + i * cellSize, startY, startX + i * cellSize, startY + gridTotalSize);
            }
        }

        function downloadPdf() {
            if (puzzleBoard.length === 0) { alert("Please generate a puzzle first."); return; }
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
            const difficulty = ui.status.textContent.split('(')[0].trim() || 'Custom';
            const puzzleData = { puzzle: puzzleBoard, difficulty: difficulty, solution: solutionBoard };
            drawPuzzlesOnPage(doc, [puzzleData], 0, {puzzlesPerPage: 1, includePageNumbers: false});
            doc.save(`Sudoku-${difficulty}.pdf`);
        }

        function drawPuzzlesOnPage(doc, puzzles, startIndex, options) {
            const { puzzlesPerPage, includePageNumbers } = options;
            const pageW = doc.internal.pageSize.getWidth(), pageH = doc.internal.pageSize.getHeight(), margin = 20, cornerRadius = 3;
            const layouts = {
                1: [{ x: (pageW - 160) / 2, y: 40, size: 160 }],
                2: [{ x: (pageW - 110) / 2, y: 25, size: 110 }, { x: (pageW - 110) / 2, y: 150, size: 110 }],
                4: [{ x: margin, y: 25, size: 80 }, { x: pageW - 80 - margin, y: 25, size: 80 }, { x: margin, y: 145, size: 80 }, { x: pageW - 80 - margin, y: 145, size: 80 }]
            };
            const layout = layouts[puzzlesPerPage] || layouts[1];

            for (let i = 0; i < puzzlesPerPage; i++) {
                const puzzleIndex = startIndex + i;
                if (puzzleIndex >= puzzles.length) break;
                const puzzleData = puzzles[puzzleIndex];
                const { x, y, size } = layout[i];
                
                const gridPadding = 4;
                const panelPadding = 5;
                const numberPanelHeight = (size / 9) + gridPadding; 
                const totalContainerHeight = size + panelPadding + numberPanelHeight;

                doc.setFont('helvetica', 'bold').setFontSize(14).text(`Puzzle ${puzzleIndex + 1}`, x + size / 2, y - 8, { align: 'center' });
                doc.setFont('helvetica', 'normal').setFontSize(10).text(`Difficulty: ${puzzleData.difficulty}`, x + size / 2, y - 2, { align: 'center' });
                doc.setDrawColor(0).setLineWidth(0.6).roundedRect(x, y, size, totalContainerHeight, cornerRadius, cornerRadius, 'S');
                
                const gridX = x + gridPadding, gridY = y + gridPadding, gridSize = size - (gridPadding * 2);
                drawSingleSudokuGrid(doc, puzzleData, gridX, gridY, gridSize, false);
                
                const panelAreaY = y + size + panelPadding;
                const panelCellGap = 2;
                const totalGapsWidth = 8 * panelCellGap;
                const panelCellSize = (size - totalGapsWidth) / 9;
                const totalPanelWidth = size;
                const panelStartX = x + (size - totalPanelWidth) / 2;
                const panelCellFontSize = (panelCellSize * 0.5) / 0.352778;

                doc.setFont('helvetica', 'bold').setFontSize(panelCellFontSize);
                for (let n = 1; n <= 9; n++) {
                    const cellX = panelStartX + (n-1) * (panelCellSize + panelCellGap);
                    const cellY = panelAreaY + (numberPanelHeight - panelCellSize) / 2;
                    doc.setDrawColor(0).setLineWidth(0.4).rect(cellX, cellY, panelCellSize, panelCellSize, 'S');
                    doc.setTextColor(0).text(String(n), cellX + panelCellSize / 2, cellY + panelCellSize / 2, { align: 'center', baseline: 'middle' });
                }
            }

            if (includePageNumbers) doc.setFont('helvetica', 'normal').setFontSize(8).text(String(Math.floor(startIndex / puzzlesPerPage) + 1), pageW / 2, pageH - 10, { align: 'center' });
        }
        
         async function createAndDownloadBook() {
            const bookOptions = {
                title: document.getElementById('book-title-input').value.trim(),
                subtitle: document.getElementById('book-subtitle-input').value.trim(),
                puzzleCount: parseInt(document.getElementById('puzzle-count-input').value, 10),
                puzzlesPerPage: parseInt(document.getElementById('puzzles-per-page-select').value, 10),
                includeSolutions: document.getElementById('answer-key-checkbox').checked,
                includePageNumbers: document.getElementById('page-numbers-checkbox').checked
            };

            if (isNaN(bookOptions.puzzleCount) || bookOptions.puzzleCount < 1 || bookOptions.puzzleCount > 100) { alert("Please enter a number between 1 and 100."); return; }
            isGeneratingBook = true;
            setUiLoading(true, "Preparing Book...");
            ui.cancelBookBtn.style.display = 'block';
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
            doc.deletePage(1);

            const allPuzzlesData = [];
            try {
                for (let i = 1; i <= bookOptions.puzzleCount; i++) {
                    if (!isGeneratingBook) throw new Error("Cancelled");
                    setUiLoading(true, `Generating Puzzle ${i} of ${bookOptions.puzzleCount}...`);
                    await new Promise(r => setTimeout(r, 10));
                    const diff = ui.difficultySelect.value;
                    const { puzzle, solution } = generateSudoku({difficulty: diff});
                    allPuzzlesData.push({ puzzle, solution, difficulty: diff.charAt(0).toUpperCase() + diff.slice(1) });
                }

                setUiLoading(true, `Building PDF...`);
                await new Promise(r => setTimeout(r, 10));

                if (bookOptions.title) {
                    doc.addPage();
                    const pageW = doc.internal.pageSize.getWidth(), pageH = doc.internal.pageSize.getHeight();
                    doc.setFont('helvetica', 'bold').setFontSize(30).text(bookOptions.title, pageW/2, pageH/2 - 10, {align: 'center'});
                    if (bookOptions.subtitle) doc.setFont('helvetica', 'normal').setFontSize(16).text(bookOptions.subtitle, pageW/2, pageH/2 + 5, {align: 'center'});
                }

                for (let i = 0; i < allPuzzlesData.length; i += bookOptions.puzzlesPerPage) {
                    if (!isGeneratingBook) throw new Error("Cancelled");
                    doc.addPage();
                    drawPuzzlesOnPage(doc, allPuzzlesData, i, bookOptions);
                }
                
                const safeTitle = (bookOptions.title.replace(/[^a-zA-Z0-9]/g, '-') || `Sudoku-Book`).substring(0, 50);
                doc.save(`${safeTitle}.pdf`);
                ui.status.textContent = "Book successfully generated!";

            } catch (error) {
                ui.status.textContent = `Error: ${error.message === "Cancelled" ? "Book generation cancelled." : error.message}`;
            } finally {
                isGeneratingBook = false;
                setUiLoading(false);
                hidePanel();
            }
        }

        // --- EVENT LISTENERS ---

        ui.grid.addEventListener('click', (e) => {
            const cell = e.target.closest('.grid-cell');
            if (cell) handleCellClick(parseInt(cell.dataset.row), parseInt(cell.dataset.col));
        });

        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (ui.createPuzzlePanel.style.display === 'block' || ui.generateBookPanel.style.display === 'block' || ui.completionModal.classList.contains('visible')) return;

            if (key === 'f') { e.preventDefault(); toggleFullScreen(); return; }
            if (key === 'n') { e.preventDefault(); defaultGame(); return; }
            if (key === 'h') { e.preventDefault(); giveHint(); return; }

            if(selectedCell.row === -1) return;
            const { row, col } = selectedCell;
            if (puzzleBoard[row][col] !== 0 || hintedCells.has(`${row},${col}`)) return;

            if (e.key >= '1' && e.key <= '9') {
                userBoard[row][col] = parseInt(e.key);
                if (isBoardFull() && checkFinalSolution()) handlePuzzleCompletion();
            } else if (['backspace', 'delete', '0'].includes(key)) {
                e.preventDefault();
                userBoard[row][col] = 0;
            }
            updateGridDisplay();
        });
        
        function toggleFullScreen() {
            if (!document.fullscreenElement) ui.gridWrapper.requestFullscreen().catch(err => alert(`Fullscreen error: ${err.message}`));
            else document.exitFullscreen();
        }
        
        // --- THEME ---
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        function setTheme(theme) { document.body.classList.toggle('dark-mode', theme === 'dark'); localStorage.setItem('theme', theme); }
        themeToggleBtn.addEventListener('click', () => setTheme(document.body.classList.contains('dark-mode') ? 'light' : 'dark'));
        const savedTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
        setTheme(savedTheme);
        
        // --- INITIALIZATION ---
        const defaultGame = () => startNewGame(new Promise(res => { const diff = ui.difficultySelect.value; res({ ...generateSudoku({difficulty: diff}), source: `Difficulty: ${diff.charAt(0).toUpperCase() + diff.slice(1)}` }) }));

        ui.generateBtn.addEventListener('click', defaultGame);
        ui.revealBtn.addEventListener('click', () => { revealSolution(); updateGridDisplay(); });
        ui.hintBtn.addEventListener('click', giveHint);
        ui.downloadPdfBtn.addEventListener('click', downloadPdf);
        ui.difficultySelect.addEventListener('change', defaultGame);
        
        ui.createPuzzleBtn.addEventListener('click', () => showPanel(ui.createPuzzlePanel));
        ui.cancelCreatePuzzleBtn.addEventListener('click', hidePanel);

        ui.startCreatedPuzzleBtn.addEventListener('click', () => {
             startNewGame(new Promise((resolve, reject) => {
                const options = {
                    completedRowCount: parseInt(ui.completedRowsInput.value, 10) || 0,
                    completedColCount: parseInt(ui.completedColsInput.value, 10) || 0,
                    completedBoxCount: parseInt(ui.completedBoxesInput.value, 10) || 0,
                };
                if (options.completedRowCount > 9 || options.completedColCount > 9 || options.completedBoxCount > 9) {
                    return reject(new Error("Completed zones cannot be greater than 9."));
                }
                
                hidePanel();
                resolve({ ...generateSudoku(options), source: `Custom Puzzle` });
            }));
        });
        
        ui.makeBookBtn.addEventListener('click', () => showPanel(ui.generateBookPanel));
        ui.cancelBookOptionsBtn.addEventListener('click', hidePanel);
        ui.createBookBtn.addEventListener('click', createAndDownloadBook);

        ui.fullscreenBtn.addEventListener('click', toggleFullScreen);
        document.querySelector('#completion-modal button').addEventListener('click', () => {
             ui.completionModal.classList.remove('visible');
             defaultGame();
        });
        
        for (let i = 1; i <= 9; i++) {
            const cell = document.createElement('div');
            cell.className = 'number-cell';
            cell.textContent = i;
            cell.dataset.number = i;
            cell.addEventListener('click', () => {
                if (selectedCell.row !== -1 && puzzleBoard[selectedCell.row][selectedCell.col] === 0 && !hintedCells.has(`${selectedCell.row},${selectedCell.col}`)) {
                    userBoard[selectedCell.row][selectedCell.col] = i;
                    updateGridDisplay();
                    if(isBoardFull() && checkFinalSolution()) handlePuzzleCompletion();
                }
            });
            ui.numberPanel.appendChild(cell);
        }
        
        document.addEventListener('fullscreenchange', updateGridDisplay);
        window.addEventListener('resize', () => { if (!document.fullscreenElement) updateGridDisplay(); });

        defaultGame();
    </script>
</body>
</html>