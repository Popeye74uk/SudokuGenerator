<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku Generator v1.4</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root {
            --color-background: #f8f9fa;
            --color-container-bg: #f8f9fa;
            --color-text-primary: #212529;
            --color-text-secondary: #6c757d;
            --color-heading: #343a40;
            --color-grid-lines: #adb5bd;
            --color-grid-box-lines: #212529; 
            --color-grid-cell-bg: #fff;
            --color-grid-given-text: #000;
            --color-grid-user-text: #007bff;
            --color-grid-selected-bg: #d0e8ff;
            --color-grid-related-bg: #e9ecef;
            --color-grid-highlighted-bg: #cce5ff;
            --color-button-disabled-bg: #6c757d;
            --color-spinner-track: #f3f3f3;
            --color-modal-bg: rgba(0, 0, 0, 0.6);
            --color-modal-content-bg: white;
            --color-box-shadow: rgba(0,0,0,0.1);
            --color-box-shadow-hover: rgba(0,0,0,0.15);
            --color-primary: #007bff;
            --color-success: #28a745;
            --color-danger: #dc3545;
            --color-warning: #ffc107;
            --color-info: #6f42c1;
            --color-pink: #d63384;
            --color-correct-bg: rgba(40, 167, 69, 0.3);
            --color-incorrect-bg: rgba(220, 53, 69, 0.4);
            --color-conflict-text: #dc3545;
        }

        body.dark-mode {
            --color-background: #121212;
            --color-container-bg: #1e1e1e;
            --color-text-primary: #e0e0e0;
            --color-text-secondary: #888;
            --color-heading: #f1f1f1;
            --color-grid-lines: #444;
            --color-grid-box-lines: #e0e0e0;
            --color-grid-cell-bg: #2a2a2a;
            --color-grid-given-text: #fff;
            --color-grid-user-text: #58a6ff;
            --color-grid-selected-bg: #3a5a78;
            --color-grid-related-bg: #343a40;
            --color-grid-highlighted-bg: #004a9e;
            --color-button-disabled-bg: #555;
            --color-spinner-track: #444;
            --color-modal-bg: rgba(0, 0, 0, 0.8);
            --color-modal-content-bg: #2c2c2c;
            --color-box-shadow: rgba(0,0,0,0.3);
            --color-box-shadow-hover: rgba(0,0,0,0.4);
            --color-correct-bg: rgba(40, 167, 69, 0.4);
            --color-incorrect-bg: rgba(220, 53, 69, 0.5);
            --color-conflict-text: #ff7b7b;
        }

        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; font-size: 16px; color: var(--color-text-primary); background-color: var(--color-background); padding: 20px; margin: 0; display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; transition: background-color 0.3s, color 0.3s; }
        .container { width: 100%; max-width: 900px; margin: 0 auto; text-align: center; }
        
        .main-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .main-header h1 { flex-grow: 1; margin: 0; padding: 0 10px; text-align: center; }
        .header-buttons { display: flex; gap: 10px; }
        .header-spacer { min-width: 100px; flex-shrink: 0; }
        
        #puzzle-container { display: flex; margin-top: 20px; justify-content: center; }
        #grid-wrapper { position: relative; }
        #grid-wrapper:fullscreen { background-color: var(--color-background); padding: 20px; display: flex; justify-content: center; align-items: center; }
        
        #grid {
            display: grid;
            grid-template-columns: repeat(9, auto);
            background-color: var(--color-grid-box-lines);
            border-right: 3px solid var(--color-grid-box-lines);
            border-bottom: 3px solid var(--color-grid-box-lines);
            border-radius: 5px;
            overflow: hidden; 
        }

        .grid-cell {
            background-color: var(--color-grid-cell-bg);
            color: var(--color-grid-user-text);
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s, color 0.2s;
            border-top: 1px solid var(--color-grid-lines);
            border-left: 1px solid var(--color-grid-lines);
        }

        .grid-cell[data-row="0"], .grid-cell[data-row="3"], .grid-cell[data-row="6"] {
            border-top-width: 3px;
            border-top-color: var(--color-grid-box-lines);
        }
        .grid-cell[data-col="0"], .grid-cell[data-col="3"], .grid-cell[data-col="6"] {
            border-left-width: 3px;
            border-left-color: var(--color-grid-box-lines);
        }

        .grid-cell.given-cell { color: var(--color-grid-given-text); font-weight: normal;}
        .grid-cell.selected { background-color: var(--color-grid-selected-bg); }
        .grid-cell.related-cell { background-color: var(--color-grid-related-bg); }
        .grid-cell.highlighted { background-color: var(--color-grid-highlighted-bg); }
        
        .grid-cell.hint-cell { color: var(--color-info); }
        .grid-cell.conflict-cell { color: var(--color-conflict-text); }
        .flash-conflict { animation: flash-red-bg 0.5s ease; }
        @keyframes flash-red-bg { 50% { background-color: var(--color-incorrect-bg); } }

        .loader { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(var(--color-container-bg), 0.8); display: flex; justify-content: center; align-items: center; flex-direction: column; gap: 15px; z-index: 10; font-size: 1.1em; color: var(--color-text-secondary); border-radius: 4px; }
        .loader.hidden { opacity: 0; pointer-events: none; }
        .spinner { border: 4px solid var(--color-spinner-track); border-top: 4px solid var(--color-primary); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
        
        .global-options-container { display: flex; justify-content: center; align-items: center; gap: 10px 25px; margin-top: 25px; font-size: 1em; color: var(--color-text-primary); }
        .controls-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; max-width: 415px; margin: 25px auto 0 auto; }
        .option-group { display: flex; align-items: center; gap: 10px; }
        
        button { padding: 12px 20px; font-size: 1em; font-weight: bold; cursor: pointer; color: white; border: none; border-radius: 5px; transition: all 0.2s; box-shadow: 0 2px 4px var(--color-box-shadow); width: 100%; box-sizing: border-box; }
        button:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 4px 8px var(--color-box-shadow-hover); }
        button:disabled { background-color: var(--color-button-disabled-bg); cursor: not-allowed; opacity: 0.7; }
        #generate-btn { background-color: var(--color-primary); }
        #reveal-btn { background-color: var(--color-success); }
        #download-pdf-btn { background-color: var(--color-pink); }
        #custom-puzzle-btn { background-color: var(--color-warning); }
        #make-book-btn { background-color: var(--color-danger); }
        #hint-btn { background-color: var(--color-info); }
        
        #custom-puzzle-panel { max-width: 415px; margin: 25px auto 0; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px var(--color-box-shadow); display: none; }
        #custom-puzzle-panel h3 { margin-top: 0; }
        #custom-puzzle-panel p { font-size: 0.9em; color: var(--color-text-secondary); margin-bottom: 15px; }
        #custom-puzzle-input { width: 100%; min-height: 100px; font-family: 'Courier New', Courier, monospace; margin-bottom: 15px; padding: 8px; box-sizing: border-box; }
        #start-custom-btn { background-color: var(--color-success); }
        #cancel-custom-btn { background-color: var(--color-text-secondary); }

        #status-container { text-align: center; margin-top: 15px; font-style: italic; min-height: 20px; color: var(--color-text-secondary); }
        #version-info { text-align: center; margin-top: 20px; font-size: 0.8em; color: var(--color-grid-lines); }
        
        #completion-modal { position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--color-modal-bg); display: flex; justify-content: center; align-items: center; z-index: 20; opacity: 0; pointer-events: none; transition: opacity 0.3s ease-in-out; border-radius: 5px; }
        #completion-modal.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background-color: var(--color-modal-content-bg); padding: 40px; border-radius: 10px; text-align: center; box-shadow: 0 5px 15px var(--color-box-shadow); transform: scale(0.9); transition: transform 0.3s ease-in-out; }
        #completion-modal.visible .modal-content { transform: scale(1); }
        .modal-content h2 { font-size: 2.5em; margin-top: 0; margin-bottom: 20px; color: var(--color-success); }
        .modal-content button { min-width: 150px; background-color: var(--color-primary); }
        #completion-details { margin-bottom: 25px; font-size: 1.1em; color: var(--color-text-primary); }
        #completion-details p { margin: 5px 0; }
        #new-best-time { color: var(--color-warning); font-weight: bold; }

        #fullscreen-btn, #theme-toggle-btn { background: none; border: 2px solid var(--color-text-secondary); color: var(--color-text-secondary); width: 44px; height: 44px; padding: 0; border-radius: 50%; display: flex; justify-content: center; align-items: center; overflow: hidden; box-shadow: none; flex-shrink: 0; }
        #fullscreen-btn:hover, #theme-toggle-btn:hover { border-color: var(--color-text-primary); color: var(--color-text-primary); transform: none; box-shadow: none; }
        #fullscreen-btn svg, #theme-toggle-btn svg { width: 24px; height: 24px; fill: currentColor; }
        .icon-sun, .icon-moon { display: none; }
        body.dark-mode .icon-sun { display: block; }
        body:not(.dark-mode) .icon-moon { display: block; }

        @media (max-width: 480px) {
            .main-header h1 { font-size: 1.8em; }
            .controls-grid { grid-template-columns: 1fr; }
            .grid-cell { font-size: 1.2em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="main-header">
            <div class="header-spacer"></div>
            <h1>Sudoku Generator</h1>
            <div class="header-buttons">
                 <button id="fullscreen-btn" title="Toggle Fullscreen (F)">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>
                </button>
                <button id="theme-toggle-btn" title="Toggle Theme">
                    <svg class="icon-sun" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.64 5.64c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41zm12.73 12.73c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0-.39.39-.39 1.02 0 1.41zM5.64 18.36c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.39-1.02-.39-1.41 0zM18.36 5.64c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41-.39-.38-1.03-.38-1.41 0z"/></svg>
                    <svg class="icon-moon" xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" viewBox="0 0 24 24"><path d="M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.11-1.36c-0.98,1.37-2.58,2.26-4.39,2.26 c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.39C12.92,3.04,12.46,3,12,3z"/></svg>
                </button>
            </div>
        </header>

        <div id="puzzle-container">
            <div id="grid-wrapper">
                <div id="grid"></div>
                <div id="loader" class="loader hidden">
                    <div class="spinner"></div>
                    <span id="loader-text">Generating Puzzle...</span>
                </div>
                <div id="completion-modal">
                    <div class="modal-content">
                        <h2>You Solved It!</h2>
                        <div id="completion-details">
                            <p id="your-time"></p>
                            <p id="best-time"></p>
                            <p id="new-best-time"></p>
                        </div>
                        <button>Play Again?</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="global-options-container">
            <div class="option-group">
                <label for="difficulty-select"><b>Difficulty:</b></label>
                <select id="difficulty-select">
                    <option value="easy">Easy</option>
                    <option value="medium" selected>Medium</option>
                    <option value="hard">Hard</option>
                    <option value="expert">Expert</option>
                </select>
            </div>
        </div>

        <div class="controls-grid" id="main-controls">
            <button id="generate-btn">New Puzzle</button>
            <button id="custom-puzzle-btn">Custom Puzzle</button>
            <button id="hint-btn">Hint</button>
            <button id="reveal-btn">Reveal Solution</button>
            <button id="download-pdf-btn">Download as PDF</button>
            <button id="make-book-btn" disabled>Make Book</button>
        </div>

        <div id="custom-puzzle-panel">
            <h3>Solve Your Own Puzzle</h3>
            <p>Enter an 81-character puzzle string. Use numbers 1-9 for clues and '0' or '.' for empty cells.</p>
            <textarea id="custom-puzzle-input" placeholder="e.g., 003020600900305001001806400008102900700000008006708200002609500800203009005010300"></textarea>
            <div class="controls-grid">
                <button id="start-custom-btn">Start Puzzle</button>
                <button id="cancel-custom-btn">Cancel</button>
            </div>
        </div>

        <div id="status-container"><p id="source-status"></p></div>
        <div id="version-info">v1.4</div>
    </div>
    
    <script>
        // --- GLOBAL VARIABLES & CONSTANTS ---
        const ui = {
            grid: document.getElementById('grid'),
            gridWrapper: document.getElementById('grid-wrapper'),
            puzzleContainer: document.getElementById('puzzle-container'),
            loader: document.getElementById('loader'),
            loaderText: document.getElementById('loader-text'),
            difficultySelect: document.getElementById('difficulty-select'),
            status: document.getElementById('source-status'),
            generateBtn: document.getElementById('generate-btn'),
            revealBtn: document.getElementById('reveal-btn'),
            hintBtn: document.getElementById('hint-btn'),
            downloadPdfBtn: document.getElementById('download-pdf-btn'),
            completionModal: document.getElementById('completion-modal'),
            fullscreenBtn: document.getElementById('fullscreen-btn'),
            themeToggleBtn: document.getElementById('theme-toggle-btn'),
            mainControls: document.getElementById('main-controls'),
            customPuzzlePanel: document.getElementById('custom-puzzle-panel'),
            customPuzzleBtn: document.getElementById('custom-puzzle-btn'),
            startCustomBtn: document.getElementById('start-custom-btn'),
            cancelCustomBtn: document.getElementById('cancel-custom-btn'),
            customPuzzleInput: document.getElementById('custom-puzzle-input')
        };

        let puzzleBoard = [], solutionBoard = [], userBoard = [];
        let selectedCell = { row: -1, col: -1 };
        let startTime, puzzleConfigKey;
        
        let hintedCells = new Set();
        let conflictCells = new Set();

        // --- SUDOKU CORE LOGIC ---

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function findEmpty(board) {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (board[r][c] === 0) return [r, c];
                }
            }
            return null;
        }

        function isValid(board, row, col, num) {
            for (let i = 0; i < 9; i++) {
                if (board[row][i] === num || board[i][col] === num) return false;
            }
            const boxRow = Math.floor(row / 3) * 3;
            const boxCol = Math.floor(col / 3) * 3;
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    if (board[boxRow + r][boxCol + c] === num) return false;
                }
            }
            return true;
        }

        function solve(board) {
            const emptyPos = findEmpty(board);
            if (!emptyPos) return true;
            const [r, c] = emptyPos;
            const nums = shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9]);

            for (const num of nums) {
                if (isValid(board, r, c, num)) {
                    board[r][c] = num;
                    if (solve(board)) return true;
                    board[r][c] = 0;
                }
            }
            return false;
        }
        
        let solutionCounter;
        function countSolutions(board) {
            const emptyPos = findEmpty(board);
            if (!emptyPos) {
                solutionCounter++;
                return;
            }
            const [r, c] = emptyPos;
            for (let num = 1; num <= 9 && solutionCounter < 2; num++) {
                if (isValid(board, r, c, num)) {
                    board[r][c] = num;
                    countSolutions(board);
                    board[r][c] = 0; // backtrack
                }
            }
        }

        function generateSudoku(difficulty) {
            const board = Array(9).fill(0).map(() => Array(9).fill(0));
            solve(board);
            solutionBoard = JSON.parse(JSON.stringify(board));
            
            let attempts;
            switch(difficulty) {
                case 'easy': attempts = 35; break;
                case 'medium': attempts = 45; break; 
                case 'hard': attempts = 50; break;
                case 'expert': attempts = 54; break;
                default: attempts = 45;
            }
            
            const cells = [];
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    cells.push([r, c]);
                }
            }
            shuffle(cells);

            let removedCount = 0;
            for (const [r, c] of cells) {
                if(removedCount >= attempts) break;
                
                const backup = board[r][c];
                board[r][c] = 0;
                
                const tempBoard = JSON.parse(JSON.stringify(board));
                solutionCounter = 0;
                countSolutions(tempBoard);

                if (solutionCounter !== 1) {
                    board[r][c] = backup;
                } else {
                    removedCount++;
                }
            }
            return board;
        }

        // --- UI & DISPLAY LOGIC ---

        function updateConflicts() {
            const oldConflicts = new Set(conflictCells);
            conflictCells.clear();
            const fullBoard = puzzleBoard.map((row, r) => row.map((cell, c) => cell === 0 ? userBoard[r][c] : cell));

            for(let r = 0; r < 9; r++) {
                for(let c = 0; c < 9; c++) {
                    const num = fullBoard[r][c];
                    if (num === 0) continue;

                    for(let i = 0; i < 9; i++) {
                        if (i !== c && fullBoard[r][i] === num) { conflictCells.add(`${r},${c}`); conflictCells.add(`${r},${i}`); }
                        if (i !== r && fullBoard[i][c] === num) { conflictCells.add(`${r},${c}`); conflictCells.add(`${i},${c}`); }
                    }
                    const boxRow = Math.floor(r / 3) * 3;
                    const boxCol = Math.floor(c / 3) * 3;
                    for(let i = 0; i < 3; i++) {
                        for(let j = 0; j < 3; j++) {
                            const curR = boxRow + i;
                            const curC = boxCol + j;
                            if ((curR !== r || curC !== c) && fullBoard[curR][curC] === num) {
                                conflictCells.add(`${r},${c}`);
                                conflictCells.add(`${curR},${curC}`);
                            }
                        }
                    }
                }
            }
            return new Set([...conflictCells].filter(x => !oldConflicts.has(x)));
        }

        function isBoardFull() {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (puzzleBoard[r][c] === 0 && userBoard[r][c] === 0) {
                        return false;
                    }
                }
            }
            return true;
        }

        function setUiLoading(isLoading, message = 'Generating Puzzle...') {
            document.querySelectorAll('button, select').forEach(el => el.disabled = isLoading);
            ui.loaderText.textContent = message;
            ui.loader.classList.toggle('hidden', !isLoading);
        }

        function updateGridDisplay() {
            const newConflictCoords = updateConflicts();
            ui.grid.innerHTML = '';
            
            const containerSize = Math.min(ui.puzzleContainer.clientWidth, 600);
            const cellSize = Math.floor(containerSize / 9);

            ui.grid.style.gridTemplateColumns = `repeat(9, ${cellSize}px)`;
            
            const selectedValue = (selectedCell.row !== -1) ? (userBoard[selectedCell.row][selectedCell.col] || puzzleBoard[selectedCell.row][selectedCell.col]) : 0;

            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.style.width = `${cellSize}px`;
                    cell.style.height = `${cellSize}px`;
                    cell.style.fontSize = `${cellSize * 0.5}px`;
                    
                    const coordKey = `${r},${c}`;
                    const isGiven = puzzleBoard[r][c] !== 0;
                    const isHinted = hintedCells.has(coordKey);
                    const currentValue = isGiven ? puzzleBoard[r][c] : userBoard[r][c];
                    
                    cell.textContent = currentValue === 0 ? '' : currentValue;
                    if (isGiven) cell.classList.add('given-cell');
                    if (isHinted) cell.classList.add('hint-cell');
                    if (conflictCells.has(coordKey)) cell.classList.add('conflict-cell');
                    if (newConflictCoords.has(coordKey)) {
                        cell.classList.add('flash-conflict');
                        cell.addEventListener('animationend', () => cell.classList.remove('flash-conflict'), { once: true });
                    }
                    
                    if (selectedCell.row !== -1) {
                         if (r === selectedCell.row && c === selectedCell.col) {
                            cell.classList.add('selected');
                        } else if (r === selectedCell.row || c === selectedCell.col || (Math.floor(r/3) === Math.floor(selectedCell.row/3) && Math.floor(c/3) === Math.floor(selectedCell.col/3))) {
                            cell.classList.add('related-cell');
                        }
                        
                        if (selectedValue !== 0 && currentValue === selectedValue) {
                           cell.classList.add('highlighted');
                        }
                    }

                    ui.grid.appendChild(cell);
                }
            }
        }

        async function startNewGame(puzzlePromise) {
            setUiLoading(true);
            ui.status.textContent = '';
            hintedCells.clear();
            
            await new Promise(resolve => setTimeout(resolve, 50));

            try {
                const { puzzle, solution, source } = await puzzlePromise;
                puzzleBoard = puzzle;
                solutionBoard = solution;
                userBoard = Array(9).fill(0).map(() => Array(9).fill(0));
                handleCellClick(-1, -1); 
                
                updateGridDisplay();
                startTime = Date.now();
                puzzleConfigKey = `sudoku-custom-${puzzle.join('')}`;
                ui.status.textContent = source;

            } catch(error) {
                ui.status.textContent = `Error: ${error.message}`;
                alert(`Error: ${error.message}`);
                console.error(error);
            } finally {
                setUiLoading(false);
            }
        }

        function checkFinalSolution() {
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const expected = solutionBoard[r][c];
                    const actual = userBoard[r][c] || puzzleBoard[r][c];
                    if (expected !== actual) return false;
                }
            }
            return true;
        }

        function revealSolution() {
            userBoard = JSON.parse(JSON.stringify(solutionBoard));
            handleCellClick(-1,-1);
            updateGridDisplay();
            ui.hintBtn.disabled = true;
            ui.revealBtn.disabled = true;
        }

        function giveHint() {
            const emptyCells = [];
            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    const coordKey = `${r},${c}`;
                    if (puzzleBoard[r][c] === 0 && userBoard[r][c] === 0 && !hintedCells.has(coordKey)) {
                        emptyCells.push({ r, c });
                    }
                }
            }
            if (emptyCells.length > 0) {
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                const { r, c } = randomCell;
                userBoard[r][c] = solutionBoard[r][c];
                hintedCells.add(`${r},${c}`);
                handleCellClick(r,c);
                if (isBoardFull() && checkFinalSolution()) {
                    handlePuzzleCompletion();
                }
            } else {
                ui.status.textContent = "No empty cells to provide a hint for!";
            }
        }
        
        function handlePuzzleCompletion() {
            const elapsedTime = Date.now() - startTime;
            const bestTime = localStorage.getItem(puzzleConfigKey);
            let isNewBest = false;
            
            if (!bestTime || elapsedTime < parseInt(bestTime, 10)) {
                localStorage.setItem(puzzleConfigKey, elapsedTime);
                isNewBest = true;
            }

            const formatTime = (ms) => {
                const s = Math.floor(ms / 1000);
                return `${String(Math.floor(s / 60)).padStart(2, '0')}:${String(s % 60).padStart(2, '0')}`;
            };
            
            document.getElementById('your-time').textContent = `Your time: ${formatTime(elapsedTime)}`;
            document.getElementById('best-time').textContent = `Best time: ${formatTime(localStorage.getItem(puzzleConfigKey))}`;
            document.getElementById('new-best-time').textContent = isNewBest ? 'New Best Time!' : '';
            ui.completionModal.classList.add('visible');
        }

        function handleCellClick(row, col) {
            selectedCell.row = row;
            selectedCell.col = col;
            updateGridDisplay();
        }

        function showCustomPanel() {
            ui.mainControls.style.display = 'none';
            ui.customPuzzlePanel.style.display = 'block';
        }

        function hideCustomPanel() {
            ui.mainControls.style.display = 'grid';
            ui.customPuzzlePanel.style.display = 'none';
        }

        // --- PDF Generation ---

        function drawSudokuOnPdfPage(doc, puzzleData) {
            const { puzzle, difficulty, title } = puzzleData;
            const pageW = doc.internal.pageSize.getWidth();
            const margin = 20;
            let currentY = margin;

            doc.setFont('helvetica', 'bold').setFontSize(20).text(title, pageW / 2, currentY, { align: 'center' });
            currentY += 8;
            doc.setFont('helvetica', 'normal').setFontSize(12).text(`Difficulty: ${difficulty}`, pageW / 2, currentY, { align: 'center' });
            currentY += 15;

            const gridTotalSize = 160;
            const contentWidth = gridTotalSize + 10;
            const startX = (pageW - gridTotalSize) / 2;
            const startY = currentY;

            const contentHeight = gridTotalSize + 10;

            doc.setDrawColor(0);
            doc.setLineWidth(0.5);
            doc.roundedRect((pageW - contentWidth) / 2, startY - 5, contentWidth, contentHeight, 3, 3, 'S');

            const cellSize = gridTotalSize / 9;
            const fontSize = (cellSize * 0.7) / 0.352778; 
            doc.setFont('helvetica', 'normal').setFontSize(fontSize).setTextColor(0);

            for (let r = 0; r < 9; r++) {
                for (let c = 0; c < 9; c++) {
                    if (puzzle[r][c] !== 0) {
                        const x = startX + c * cellSize + cellSize / 2;
                        const y = startY + r * cellSize + cellSize / 2;
                        doc.text(String(puzzle[r][c]), x, y, { align: 'center', baseline: 'middle' });
                    }
                }
            }

            doc.setDrawColor(0);
            for (let i = 0; i <= 9; i++) {
                const isThick = i % 3 === 0;
                doc.setLineWidth(isThick ? 0.6 : 0.2);
                doc.line(startX, startY + i * cellSize, startX + gridTotalSize, startY + i * cellSize);
                doc.line(startX + i * cellSize, startY, startX + i * cellSize, startY + gridTotalSize);
            }
        }

        function downloadPdf() {
            if (puzzleBoard.length === 0) {
                alert("Please generate a puzzle first.");
                return;
            }
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' });
            const difficulty = ui.status.textContent.split(': ')[1] || 'Custom';
            
            drawSudokuOnPdfPage(doc, {
                puzzle: puzzleBoard,
                difficulty: difficulty,
                title: "Sudoku Puzzle"
            });
            doc.save(`Sudoku-${difficulty}.pdf`);
        }


        // --- EVENT LISTENERS ---

        ui.grid.addEventListener('click', (e) => {
            const cell = e.target.closest('.grid-cell');
            if (cell) {
                handleCellClick(parseInt(cell.dataset.row), parseInt(cell.dataset.col));
            }
        });

        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if(ui.completionModal.classList.contains('visible') || ui.customPuzzlePanel.style.display === 'block') return;

            if (key === 'f') { e.preventDefault(); toggleFullScreen(); return; }
            if (key === 'n') { e.preventDefault(); startNewGame(new Promise(res => { const diff = ui.difficultySelect.value; res({ puzzle: generateSudoku(diff), solution: solutionBoard, source: `Difficulty: ${diff.charAt(0).toUpperCase() + diff.slice(1)}` }) })); return; }
            if (key === 'h') { e.preventDefault(); giveHint(); return; }

            if(selectedCell.row === -1) return;
            
            const { row, col } = selectedCell;

            if (puzzleBoard[row][col] !== 0 || hintedCells.has(`${row},${col}`)) return;

            if (e.key >= '1' && e.key <= '9') {
                userBoard[row][col] = parseInt(e.key);
                updateGridDisplay();
                if (isBoardFull() && checkFinalSolution()) {
                    handlePuzzleCompletion();
                }
            } else if (e.key === 'Backspace' || e.key === 'Delete' || e.key === '0') {
                e.preventDefault();
                userBoard[row][col] = 0;
                updateGridDisplay();
            }
        });
        
        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                ui.gridWrapper.requestFullscreen().catch(err => {
                    alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        }
        
        // --- THEME ---
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        function setTheme(theme) { document.body.classList.toggle('dark-mode', theme === 'dark'); localStorage.setItem('theme', theme); }
        themeToggleBtn.addEventListener('click', () => setTheme(document.body.classList.contains('dark-mode') ? 'light' : 'dark'));
        const savedTheme = localStorage.getItem('theme'), prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        setTheme(savedTheme || (prefersDark ? 'dark' : 'light'));
        
        // --- INITIALIZATION ---
        ui.generateBtn.addEventListener('click', () => startNewGame(new Promise(res => { const diff = ui.difficultySelect.value; res({ puzzle: generateSudoku(diff), solution: solutionBoard, source: `Difficulty: ${diff.charAt(0).toUpperCase() + diff.slice(1)}` }) })));
        ui.revealBtn.addEventListener('click', revealSolution);
        ui.hintBtn.addEventListener('click', giveHint);
        ui.downloadPdfBtn.addEventListener('click', downloadPdf);
        ui.difficultySelect.addEventListener('change', () => startNewGame(new Promise(res => { const diff = ui.difficultySelect.value; res({ puzzle: generateSudoku(diff), solution: solutionBoard, source: `Difficulty: ${diff.charAt(0).toUpperCase() + diff.slice(1)}` }) })));
        
        ui.customPuzzleBtn.addEventListener('click', showCustomPanel);
        ui.cancelCustomBtn.addEventListener('click', hideCustomPanel);
        ui.startCustomBtn.addEventListener('click', () => {
             startNewGame(new Promise((resolve, reject) => {
                const input = ui.customPuzzleInput.value.replace(/\./g, '0').trim();
                if (input.length !== 81 || !/^[0-9]{81}$/.test(input)) {
                    return reject(new Error("Invalid puzzle string. Must be 81 characters, containing only numbers 0-9 or '.'"));
                }
                
                const pBoard = [];
                for(let i=0; i<9; i++) pBoard.push(input.substring(i*9, (i+1)*9).split('').map(Number));

                const sBoard = JSON.parse(JSON.stringify(pBoard));
                if(!solve(sBoard)) return reject(new Error("This puzzle is not solvable."));

                const tempBoard = JSON.parse(JSON.stringify(pBoard));
                solutionCounter = 0;
                countSolutions(tempBoard);
                if (solutionCounter > 1) return reject(new Error("This puzzle has multiple solutions and is not valid."));
                
                hideCustomPanel();
                resolve({ puzzle: pBoard, solution: sBoard, source: 'Custom Puzzle' });
            }));
        });
        
        ui.fullscreenBtn.addEventListener('click', toggleFullScreen);
        document.querySelector('#completion-modal button').addEventListener('click', () => {
             ui.completionModal.classList.remove('visible');
             startNewGame(new Promise(res => { const diff = ui.difficultySelect.value; res({ puzzle: generateSudoku(diff), solution: solutionBoard, source: `Difficulty: ${diff.charAt(0).toUpperCase() + diff.slice(1)}` }) }));
        });
        document.addEventListener('fullscreenchange', updateGridDisplay);
        window.addEventListener('resize', () => { if (!document.fullscreenElement) { updateGridDisplay(); } });

        startNewGame(new Promise(res => { const diff = ui.difficultySelect.value; res({ puzzle: generateSudoku(diff), solution: solutionBoard, source: `Difficulty: ${diff.charAt(0).toUpperCase() + diff.slice(1)}` }) }));
    </script>
</body>
</html>